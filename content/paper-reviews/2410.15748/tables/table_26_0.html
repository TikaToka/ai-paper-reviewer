<table id='0' style='font-size:16px'><tr><td>StrictMonoOn.mapsTo_Ioc</td></tr><tr><td>lemma StrictMonoOn.mapsTo_Ioc (h : StrictMonoOn f (Icc a b)) : MapsTo f (Ioc a b) (Ioc (fa) (fb)) := fun c hc → 〈h (left_ mem Icc.2 < hc.1.le.trans hc.2) (Ioc_subset Icc⌀ self hc) hc.1, h.monotoneOn (Ioc_subset_ Icc_self hc) (right_ mem Icc.2 V hc.1.le.trans hc.2) hc.2)</td></tr><tr><td>example (h : StrictMonoOn f (Icc a b) ↔ True) : MapsTo f (Ioc a b) (Ioc (fa) (fb)):= have h : StrictMonoOn f (Icc a b) := by apply of_iff_ true; assumption fun c hc → 〈h (left_ mem Icc.2 <| hc.1.le.trans hc.2) (Ioc_subset_ Icc_ self hc) hc.1, h.monotoneOn (Ioc_subset_Icc_self hc) (right_mem_Icc.2 ◁ hc.1.le.trans hc.2) hc.2)</td></tr><tr><td>example (H : � (b_1 : Prop), (StrictMonoOn f (Icc a b) → b_1)→ StrictMonoOn f (Icc a b)) : MapsTo f (Ioc ab) (Ioc (fa) (fb)):= have h : StrictMonoOn f (Icc a b) := by apply peirce'; assumption ... example (h : Icc a b E {x  StrictMonoOn fx}) : MapsTo f (Ioc a b) (Ioc (fa) (fb)):= have h : StrictMonoOn f (Icc a b) := by apply Membership.mem.out; assumption ...</td></tr><tr><td>PNat.XgcdType.reduce_ a</td></tr><tr><td>theorem reduce_a {u : XgcdType} (h : u.r = 0) : u.reduce = u.finish := by rw [reduce] exact if _pos h example {u : XgcdType} (h : 0|ru) : u.reduce = u.finish:= by have h : u.r = 0 := by apply Nat.eq_ zero_of_ zero_dvd; assumption rw [reduce] exact if_pos h</td></tr><tr><td>example {u : XgcdType} (H : u.bp + 1 I u.ap + 1) : u.reduce = u.finish:= by have h : u.r = 0 := by apply Nat.mod_eq_zero_of_dvd; assumption ... example {u : XgcdType} (n : N) (H : Nat.gcd (ru) n = 0) : u.reduce = u.finish:= by have h : u.r = 0 := by apply Nat.eq_ zero_ of_gcd_eq_zero_left<;> assumption</td></tr><tr><td>Ordnode.not le_ delta</td></tr><tr><td>theorem not le delta {s} (H : 1 ≤s) : �S ≤ delta * 0 := not le of gt H</td></tr><tr><td>example {s} (h : 0<s) (a : 1 ls) : js ≤ delta * 0:= have H : 1 ≤s := by apply Nat.le_of_dvd<;> assumption not_le_of_gt H example {s} (n : N) (H1 : s In) (H2 : 0<n) : ーs ≤ delta * 0:= have H : 1 ⌀s = by apply Nat.pos_of_dvd_of_pos<;> assumption ... example {s} (1 : List N) (p : List.Pairwise LE.le (1 :: 1)) (a : sE1) : �S ≤ delta * 0:= have H : 1 ⌀s = by apply List.rel of pairwise_cons<;> assumption</td></tr></table>